üîπ 1. Bubble Sort

√â o mais simples de todos.
Funciona trocando elementos vizinhos repetidamente at√© que a lista esteja ordenada.
√â ineficiente para listas grandes (complexidade O(n¬≤)).
Bom para fins did√°ticos.

#include <iostream>
using namespace std;

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) { // Vai verificar se o atual elemento do array √© maior que o pr√≥ximo
                swap(arr[j], arr[j+1]); // Se for maior, ele trocar√° o valor desses elementos (no caso, o antigo valor do atual, indo para a direita)
            }
        }
    }
}

int main() {
    int arr[] = {5, 3, 8, 4, 2};
    int n = 5; // tamanho do array

    bubbleSort(arr, n);

    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}


üîπ 2. Quick Sort

Baseado na estrat√©gia Dividir para Conquistar.
Escolhe um piv√¥, reorganiza o array de forma que elementos menores fiquem antes do piv√¥ e maiores depois.
Aplica recursivamente nas duas partes.
Muito eficiente na pr√°tica (O(n log n) em m√©dia, mas pode ser O(n¬≤) no pior caso se escolher piv√¥ ruim).


#include <iostream>
using namespace std;

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1; // marca a posi√ß√£o do √∫ltimo elemento menor que o piv√¥

    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++; // A compara√ß√£o com o piv√¥ SEMPRE come√ßa pelo indice 0; 
            swap(arr[i], arr[j]); // coloca arr[j] logo ap√≥s os menores j√° encontrados.
        }
    }
    swap(arr[i+1], arr[high]); // coloca o piv√¥ na posi√ß√£o i+1, que √© o lugar correto.
    return i+1; // retorna a posi√ß√£o final do piv√¥.
}

void quickSort(int arr[], int low, int high) {
    if (low < high) { // s√≥ vai fazer se houver pelo menos 2 elementos
        int pi = partition(arr, low, high); // chama a fun√ß√£o de parti√ß√£o e pega a posi√ß√£o do piv√¥
        quickSort(arr, low, pi-1); // ordena a parte da esquerda do piv√¥ (menores)
        quickSort(arr, pi+1, high); // ordena a parte da direita do piv√¥ (maiores ou iguais)
    }
}

int main() {
    int arr[] = {5, 3, 8, 4, 2}; // Piv√¥ = 2 (indice 4)
    int n = 5; 

    quickSort(arr, 0, n-1); // ele chama a fun√ß√£o quickSort, na qual ser√° feito o seu algoritmo no array criado no main
    //(arr): sendo o nome, (0): indice inicial, (n-1): indice final.

    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}


üîπ 3. Merge Sort

Tamb√©m segue Dividir para Conquistar.
Divide o array em duas metades, ordena cada uma recursivamente e depois funde (merge) as duas listas j√° ordenadas.
Sempre tem complexidade O(n log n).
Mais est√°vel que o QuickSort (mant√©m ordem relativa de iguais).


#include <iostream>
using namespace std;

void merge(int arr[], int l, int m, int r) {
    int n1 = m - l + 1; // tamnho da primeira metade
    int n2 = r - m; // tamanho da segunda metade 

    int L[n1], R[n2];

    for (int i = 0; i < n1; i++) {
        L[i] = arr[l+i]; // copia a primeira metade para o l
    }
    
    for (int j = 0; j < n2; j++) {
        R[j] = arr[m+1+j]; // copia a segunda metade para o R
    }

    int i = 0, j = 0, k = l; // i percorre l, j percorre o R e k ir√° copiar para o arr.
    
    while (i < n1 && j < n2) { // Compara√ß√£o das duas metades j√° fundidas.
        
        if (L[i] <= R[j]) { // Se o proximo de L for menor ou igual, copia L e avan√ßa i e k
            arr[k++] = L[i++];
            }
        
        else { // Sen√£o, copia para o R.
            arr[k++] = R[j++];
        }
    }

    while (i < n1) {
        arr[k++] = L[i++]; // Copia o que sobrou de L (se houver)
    }
    while (j < n2) {
        arr[k++] = R[j++]; // Copia o que sobrou de R (se houver tamb√©m)
    }
}

void mergeSort(int arr[], int l, int r) { // Fun√ß√£o que divide o array.
    if (l < r) { // para continuar esta condi√ß√£o, tem que ter pelo menos 2 elementos
        int m = l + (r - l) / 2; // F√≥rmula para calcular o meio do array.
        mergeSort(arr, l, m); // Ordena a parte da esquerda 
        mergeSort(arr, m+1, r); // Ordena a parte da direita
        merge(arr, l, m, r); // Junta as duas partes ordenadas
    }
}

int main() {
    int arr[] = {5, 3, 8, 4, 2};
    int n = 5;

    mergeSort(arr, 0, n-1);

    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}

üîπ 4. Heap Sort

Usa a estrutura de heap (uma √°rvore bin√°ria quase completa).
Primeiro transforma o array em um heap m√°ximo.
Depois, remove o maior elemento (raiz) e coloca no final, repetindo at√© ordenar.
Complexidade O(n log n) em todos os casos.  


#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i) {
    int largest = i; // Assume que a raiz i √© a maior
    
    //Representa√ß√£o das indices dos filhos em array
    int left = 2*i + 1; // indice do filho esquerdo
    int right = 2*i + 2; // indice do filho direito 

    if (left < n && arr[left] > arr[largest]) // Verifica se o filho esquerdo existe e se √© maior que a raiz
        largest = left;

    if (right < n && arr[right] > arr[largest]) // Mesma condi√ß√£o para o lado direito
        largest = right;

    if (largest != i) { // Condi√ß√£o que verifica se um dos filhos √© maior que a raiz
        swap(arr[i], arr[largest]); // troca o valor da raiz com o valor do filho.
        heapify(arr, n, largest); // chama a fun√ß√£o para consertar a subarvore afetada.
    }
}

void heapSort(int arr[], int n) {
    for (int i = n/2 - 1; i >= 0; i--) { // Constr√≥i o heap m√°ximo a partir do array desordenado
    // Na qual, n/2 - 1, s√£o os n√≥s internos (que obt√©m pelo menos um filho).
    // Exemplo: n = 8, 8/2 - 1 = 3, ou seja, o la√ßo come√ßa no indice 3 e vai at√© 0. Esses s√£o os n√≥s que tem filhos.
        heapify(arr, n, i); // Garante que a subarvore com raiz i respeite a propriedade de heap m√°ximo.
    }

    for (int i = n-1; i >= 0; i--) { // extrair o m√°ximo e reduzir o heap.
        swap(arr[0], arr[i]); // Colocar o maior (raiz) na posi√ß√£o final
        heapify(arr, i, 0); // reconstroi o heap no restante do array para encontrar o pr√≥ximo maior. 
    }
}

int main() {
    int arr[] = {5, 3, 8, 4, 2};
    int n = 5;
    
    // Arvore bin√°ria:  5 (√≠ndice 0)
    //                   /       \
   //               3 (1)        8 (2)
   //               /    \          
//              4 (3) 2 (4) 

    heapSort(arr, n);

    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}
